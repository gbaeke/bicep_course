<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>HTML TABLE</title>
</head><body>
<table>
<colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup>
<tr><th>detail</th><th>field</th><th>info</th><th>level</th><th>outcome</th><th>outcomeReason</th><th>ref</th><th>ruleName</th><th>runId</th><th>source</th><th>tag</th><th>targetName</th><th>targetType</th><th>time</th></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=Template string parameters can optionally specify a strong type. When parameter files are expanded, if the parameter value does not match the type this rule fails. Support is provided by PSRule for Azure for the following types:

- Resource type - Specify a resource type.
  For example Microsoft.OperationalInsights/workspaces.   If a resource type is specified the parameter value must be a resource id of that type.
- Location - Specify location as the strong type.
  If location is specified, the parameter value must be a valid Azure location.; displayName=Parameter value should match strong type; moduleName=PSRule.Rules.Azure; name=Azure.Template.ParameterStrongType; recommendation=Consider updating the parameter value to a value that matches the specifed strong type.; synopsis=Set the parameter value to a value that matches the specified strong type.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000227</td><td>Azure.Template.ParameterStrongType</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2021_12; azure.WAF/pillar=Operational Excellence}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=Extremely long expressions may be difficult to read and debug. Avoid using expressions that exceed 24,576 characters in length.; displayName=Template expressions should not exceed a maximum length; moduleName=PSRule.Rules.Azure; name=Azure.Template.ExpressionLength; recommendation=Consider updating the expression to reduce complexity and length.; synopsis=Template expressions should not exceed the maximum length.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000228</td><td>Azure.Template.ExpressionLength</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2021_12; azure.WAF/pillar=Operational Excellence}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=This rule checks for cases when a sensitive value is output from a deployment. For example, if a parameter is marked as secure and then assigned to an output value.
Don&#39;t include any values in an ARM template or Bicep output that could potentially expose sensitive information. The output from each deployment is stored in the deployment history. If the output contains sensitive information, the output value is leaked to the deployment history.
Examples of secrets are:

- Parameters using the secureString or secureObject type.
- Output from list* functions such as listKeys.

Outputs are recorded in clear texts within deployment history and logs. Logs are often exposed at multiple levels including CI pipeline logs, Azure Activity Logs, and SIEM systems.
&lt;!-- security:note rotate-secret --&gt;; displayName=Deployment exposes a secret in output; moduleName=PSRule.Rules.Azure; name=Azure.Deployment.OutputSecretValue; recommendation=Consider removing any output values that return secret values in code.; synopsis=Outputting a sensitive value from deployment may leak secrets into deployment history or logs.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000279</td><td>Azure.Deployment.OutputSecretValue</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2022_06; azure.WAF/pillar=Security}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=Resource properties can be configured using a hardcoded value or Azure Bicep/ template expressions. When specifying sensitive values use secure parameters. Secure parameters use the @secure decorator in Bicep or the secureString / secureObject type.
Sensitive values that use deterministic expressions such as hardcoded string literals or variables are not secure. These values can be read by anyone with read access to deployment history or logs. Logs are often exposed at multiple levels including CI pipeline logs, Azure Activity Logs, and SIEM systems.
&lt;!-- security:note rotate-secret --&gt;; displayName=Deployment uses deterministic credential values; moduleName=PSRule.Rules.Azure; name=Azure.Deployment.AdminUsername; recommendation=Sensitive properties should be passed as parameters. Avoid using deterministic or hardcoded values for sensitive properties.; synopsis=A sensitive property set from deterministic or hardcoded values is not secure.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000284</td><td>Azure.Deployment.AdminUsername</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2022_09; azure.WAF/pillar=Security}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=This rule uses a heuristics to determine if a parameter should use a secure type based on how it is named. For example if the parameter is named password it is likely to contain a password value. However, there are cases when the parameter name may be confused with a sensitive value, but the value is not sensitive. See notes below for more details.
Azure Bicep and Azure Resource Manager (ARM) templates can be used to deploy resources to Azure. When deploying Azure resources, sensitive values such as passwords, certificates, and keys should be passed as secure parameters. Secure parameters use the @secure decorator in Bicep or the secureString / secureObject type.
Parameters that do not use secure types are recorded in deployment history and logs. These values can be retrieved by anyone with read access to the deployment history and logs.
&lt;!-- security:note rotate-secret --&gt;
&lt;!-- security:note non-secret-values --&gt;; displayName=Deployment parameter name implies it is secret but is a non-secure value; moduleName=PSRule.Rules.Azure; name=Azure.Deployment.SecureParameter; recommendation=Consider using secure parameters for any parameter that contain sensitive information.; synopsis=Sensitive parameters that have been not been marked as secure may leak the secret into deployment history or logs.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000408</td><td>Azure.Deployment.SecureParameter</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2023_12; azure.WAF/pillar=Security}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=This rule checks for cases when a non-secure value is assigned to a resource property that contains sensitive information. For example, a regular parameter or hard coded variable is used to set the value property of an Azure Key Vault secret. This property is used to store the secret value in the Key Vault, however the value has been leaked.
Azure Bicep and Azure Resource Manager (ARM) templates can be used to deploy resources to Azure. When deploying Azure resources, sensitive values such as passwords, certificates, and keys should be passed as secure parameters. Secure parameters use the @secure decorator in Bicep or the secureString / secureObject type.
Parameters that do not use secure types are recorded in deployment history and logs. These values can be retrieved by anyone with read access to the deployment history and logs. Logs are often exposed at multiple levels including CI pipeline logs, Azure Activity Logs, and SIEM systems.
&lt;!-- security:note rotate-secret --&gt;
&lt;!-- security:note non-secret-values --&gt;; displayName=Deployment sets a secret property with a non-secure value; moduleName=PSRule.Rules.Azure; name=Azure.Deployment.SecureValue; recommendation=Consider using secure parameters for setting the value of any sensitive resource properties.; synopsis=A secret property set from a non-secure value may leak the secret into deployment history or logs.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000316</td><td>Azure.Deployment.SecureValue</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2024_12; azure.WAF/pillar=Security}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Resources/deployments/helper; subscriptionId=}</td><td>@{annotations=; description=This rule detects cases when a sensitive value is passed to a parameter that is not marked as secure. For example, you used listKeys to get a storage account key and then passed the value to a parameter of a child module. The parameter on the child module is not marked as secure, so the value has been leaked by the child deployment.
Azure Bicep and Azure Resource Manager (ARM) templates can be used to deploy resources to Azure. When deploying Azure resources, sensitive values such as passwords, certificates, and keys should be passed as secure parameters. Secure parameters use the @secure decorator in Bicep or the secureString / secureObject type.
Parameters that do not use secure types are recorded in deployment history and logs. These values can be retrieved by anyone with read access to the deployment history and logs.
&lt;!-- security:note rotate-secret --&gt;
&lt;!-- security:note non-secret-values --&gt;; displayName=Deployment parameter contains a secret that is not secured; moduleName=PSRule.Rules.Azure; name=Azure.Deployment.SecretLeak; recommendation=Consider using secure parameters for any parameter that contain sensitive information.; synopsis=Sensitive parameters that have been not been marked as secure may leak the secret into deployment history or logs.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000459</td><td>Azure.Deployment.SecretLeak</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2025_06; azure.WAF/pillar=Security}</td><td>/Users/geertbaeke/projects/bicep_course/step2.bicep</td><td>Microsoft.Resources/deployments</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/serverfarms/myAppServicePlan; subscriptionId=}</td><td>@{annotations=; description=Azure Resource Manager (ARM) supports a flexible tagging model that allows each resource to be tagged. Tags are additional metadata that improves identification of resources and aids lifecycle management.
Azure stores tags as name/ value pairs such as environment = production or costCode = 349921.
A well defined tagging approach improves the management, billing, and automation operations of resources. When planning tags, identify information that is meaningful to business and technical staff.
Azure provides several built-in policies to managed tags. Using these policies help enforce a tagging standard can reduce overall management Resource tags can be inherited from subscriptions or resource groups using Azure Policy.; displayName=Use resource tags; moduleName=PSRule.Rules.Azure; name=Azure.Resource.UseTags; recommendation=Consider tagging resources using a standard convention. Identify mandatory and optional tags then tag all resources and resource groups using this standard.
Also consider using Azure Policy to enforce mandatory tags.; synopsis=Azure resources should be tagged using a standard convention.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000166</td><td>Azure.Resource.UseTags</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Cost Optimization}</td><td>myAppServicePlan</td><td>Microsoft.Web/serverfarms</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/serverfarms/myAppServicePlan; subscriptionId=}</td><td>@{annotations=; description=Azure supports deployment to many locations around the world called regions. Many organizations have requirements that limit where data can be stored or processed. This is commonly known as data residency.
Most Azure resources must be deployed to a specific region. To align with your organizational requirements, you may choose to limit the regions that resources can be deployed to.
Some resources, particularly those related to preview services or features, may not be available in all regions.; displayName=Use allowed regions; moduleName=PSRule.Rules.Azure; name=Azure.Resource.AllowedRegions; recommendation=Consider deploying resources to allowed regions to align with your organizational requirements. Also consider using Azure Policy to enforce allowed regions at runtime.; synopsis=Resources should be deployed to allowed regions.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000167</td><td>Azure.Resource.AllowedRegions</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Security}</td><td>myAppServicePlan</td><td>Microsoft.Web/serverfarms</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/serverfarms/myAppServicePlan; subscriptionId=}</td><td>@{annotations=; description=App Services Plans provides a configurable number of instances that will run apps. When a single instance is configured your app may be temporarily unavailable during unplanned interruptions. In most circumstances, Azure will self heal faulty app service instances automatically. However during this time there may interruptions to your workload.
This rule does not apply to consumption or elastic App Services Plans.; displayName=Use two or more App Service Plan instances; moduleName=PSRule.Rules.Azure; name=Azure.AppService.PlanInstanceCount; recommendation=Consider using an App Service Plan with at least two (2) instances.; synopsis=App Service Plan should use a minimum number of instances for failover.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000071</td><td>Azure.AppService.PlanInstanceCount</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Reliability}</td><td>myAppServicePlan</td><td>Microsoft.Web/serverfarms</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/serverfarms/myAppServicePlan; subscriptionId=}</td><td>@{annotations=; description=App Service plans support zone redundancy, which distributes your application running within the plan across Availablity Zones. Each Availability Zone is a group of phyiscally separated data centers. Deploying your application with zone redundancy:

- Scales your plan to a minimum of 3 instances in a highly available configuration.
  Additional instances can be added manually or on-demand by using autoscale.
- Improves the resiliency against service disruptions or issues affecting a single zone.

Additionally:

- Even Distribution: If the instance count is larger than 3 and divisible by 3, instances are evenly distributed across the three zones.
- Partial Distribution: Instance counts beyond 3*N are spread across the remaining one or two zones to ensure balanced distribution.

Important Configuring zone redundancy with per-application scaling is possible but may increase costs and administrative overhead. When perSiteScaling is enabled, each application can have its own scaling rules and run on dedicated instances. To maintain zone redundancy, it is crucial that each application’s scaling rules ensure a minimum of 3 instances. Without explicitly configuring this minimum, the application may not meet the zone redundancy requirement.; displayName=Deploy app service plan instances using availability zones; moduleName=PSRule.Rules.Azure; name=Azure.AppService.AvailabilityZone; recommendation=Consider using enabling zone redundancy using availability zones to improve the resiliency of your solution.; synopsis=Deploy app service plan instances using availability zones in supported regions to ensure high availability and resilience.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000442</td><td>Azure.AppService.AvailabilityZone</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2024_09; azure.WAF/pillar=Reliability}</td><td>myAppServicePlan</td><td>Microsoft.Web/serverfarms</td><td>6</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/serverfarms/myAppServicePlan; subscriptionId=}</td><td>@{annotations=; description=Azure App Services provide a range of different plans that can be used to scale your application. Each plan provides different levels of performance and features.
To get you started a number of entry level plans are available. The Free, Shared, and Basic plans can be used for limited testing and development. However these plans are not suitable for production use. Production workloads are best suited to standard and premium plans with PremiumV3 the newest plan.
This rule does not apply to consumption or elastic App Services Plans used for Azure Functions.; displayName=Use App Service production SKU; moduleName=PSRule.Rules.Azure; name=Azure.AppService.MinPlan; recommendation=Consider using a standard or premium plan for hosting apps on Azure App Service.; synopsis=Use at least a Standard App Service Plan.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000072</td><td>Azure.AppService.MinPlan</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Performance Efficiency}</td><td>myAppServicePlan</td><td>Microsoft.Web/serverfarms</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure Resource Manager (ARM) supports a flexible tagging model that allows each resource to be tagged. Tags are additional metadata that improves identification of resources and aids lifecycle management.
Azure stores tags as name/ value pairs such as environment = production or costCode = 349921.
A well defined tagging approach improves the management, billing, and automation operations of resources. When planning tags, identify information that is meaningful to business and technical staff.
Azure provides several built-in policies to managed tags. Using these policies help enforce a tagging standard can reduce overall management Resource tags can be inherited from subscriptions or resource groups using Azure Policy.; displayName=Use resource tags; moduleName=PSRule.Rules.Azure; name=Azure.Resource.UseTags; recommendation=Consider tagging resources using a standard convention. Identify mandatory and optional tags then tag all resources and resource groups using this standard.
Also consider using Azure Policy to enforce mandatory tags.; synopsis=Azure resources should be tagged using a standard convention.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000166</td><td>Azure.Resource.UseTags</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Cost Optimization}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure supports deployment to many locations around the world called regions. Many organizations have requirements that limit where data can be stored or processed. This is commonly known as data residency.
Most Azure resources must be deployed to a specific region. To align with your organizational requirements, you may choose to limit the regions that resources can be deployed to.
Some resources, particularly those related to preview services or features, may not be available in all regions.; displayName=Use allowed regions; moduleName=PSRule.Rules.Azure; name=Azure.Resource.AllowedRegions; recommendation=Consider deploying resources to allowed regions to align with your organizational requirements. Also consider using Azure Policy to enforce allowed regions at runtime.; synopsis=Resources should be deployed to allowed regions.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000167</td><td>Azure.Resource.AllowedRegions</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=The minimum version of TLS that Azure App Service accepts is configurable. Older TLS versions are no longer considered secure by industry standards, such as PCI DSS.
App Service lets you disable outdated protocols and enforce TLS 1.2. By default, a minimum of TLS 1.2 is enforced.; displayName=App Service site allows insecure TLS versions; moduleName=PSRule.Rules.Azure; name=Azure.AppService.MinTLS; recommendation=Consider configuring the minimum supported TLS version to be 1.2. Also consider using Azure Policy to audit or enforce this configuration.; synopsis=App Service should not accept weak or deprecated transport protocols for client-server communication.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000073</td><td>Azure.AppService.MinTLS</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Remote debugging can be enabled on apps running within Azure App Services.
To enable remote debugging, App Service allows connectivity to additional ports. While access to remote debugging ports is authenticated, the attack service for an app is increased.; displayName=Disable App Service remote debugging; moduleName=PSRule.Rules.Azure; name=Azure.AppService.RemoteDebug; recommendation=Consider disabling remote debugging when not in use.; synopsis=Disable remote debugging on App Service apps when not in use.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000074</td><td>Azure.AppService.RemoteDebug</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_12; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Within a App Service app, the version of .NET used to run application/ site code is configurable.
Overtime, a specific version of .NET may become outdated and no longer supported by Microsoft. This can lead to security vulnerabilities or are simply not able to use the latest security features.
.NET 6.0 and .NET 7.0 are approaching end of support.; displayName=Use a newer .NET version; moduleName=PSRule.Rules.Azure; name=Azure.AppService.NETVersion; recommendation=Consider updating the site to use a newer .NET version such as v8.0.; synopsis=Configure applications to use newer .NET versions.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000075</td><td>Azure.AppService.NETVersion</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2024_03; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Within a App Service app, the version of PHP runtime used to run application/ site code is configurable.
Overtime, a specific version of PHP may become outdated and no longer supported by Microsoft in Azure App Service. This can lead to security vulnerabilities or are simply not able to use the latest security features.
PHP 8.0 and 8.1 are approaching end of support.; displayName=Use a newer PHP runtime version; moduleName=PSRule.Rules.Azure; name=Azure.AppService.PHPVersion; recommendation=Consider updating the site to use a newer PHP runtime version such as 8.2.; synopsis=Configure applications to use newer PHP runtime versions.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000076</td><td>Azure.AppService.PHPVersion</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2024_03; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service apps are automatically unloaded when there&#39;s no traffic. Unloading apps reduces resource consumption when apps share a single App Services Plan. After an app have been unloaded, the next web request will trigger a cold start of the app. A cold start of the app can cause request timeouts.
Web apps using continuous WebJobs or WebJobs triggered with a CRON expression must use always on to start.; displayName=Use App Service Always On; moduleName=PSRule.Rules.Azure; name=Azure.AppService.AlwaysOn; recommendation=Consider enabling Always On for each App Services app.; synopsis=Configure Always On for App Service apps.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000077</td><td>Azure.AppService.AlwaysOn</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_12; azure.WAF/pillar=Reliability}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service has native support for HTTP/2, but by default it is disabled. HTTP/2 offers a number of improvements over HTTP/1.1, including:

- Connections are fully multiplexed, instead of ordered and blocking.
- Connections are reused, reducing connection establishment overhead.
- Headers are compressed to reduce overhead.; displayName=Use HTTP/2 connections for App Service apps; moduleName=PSRule.Rules.Azure; name=Azure.AppService.HTTP2; recommendation=Consider using HTTP/2 for Azure Services apps to improve protocol efficiency.; synopsis=Use HTTP/2 instead of HTTP/1.x to improve protocol efficiency.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000078</td><td>Azure.AppService.HTTP2</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_12; azure.WAF/pillar=Performance Efficiency}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service monitors a specific path for each web app instance to determine health status. The monitored path should implement functional checks to determine if the app is performing correctly. The checks should include dependencies including those that may not be regularly called.
Regular checks of the monitored path allow Azure App Service to route traffic based on availability.; displayName=Web apps use health probes; moduleName=PSRule.Rules.Azure; name=Azure.AppService.WebProbe; recommendation=Consider configuring a health probe to monitor instance availability.; synopsis=Configure and enable instance health probes.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000079</td><td>Azure.AppService.WebProbe</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2022_06; azure.WAF/pillar=Reliability}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service monitors a specific path for each web app instance to determine health status. The monitored path should implement functional checks to determine if the app is performing correctly. The checks should include dependencies including those that may not be regularly called.
Regular checks of the monitored path allow Azure App Service to route traffic based on availability.; displayName=Web apps use a dedicated health probe path; moduleName=PSRule.Rules.Azure; name=Azure.AppService.WebProbePath; recommendation=Consider using a dedicated health probe endpoint that implements functional checks.; synopsis=Configure a dedicated path for health probe requests.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000080</td><td>Azure.AppService.WebProbePath</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2022_06; azure.WAF/pillar=Reliability}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service supports configuration of FTP and SFTP for uploading site content. By default, both FTP and SFTP are enabled. In many circumstances, use of FTP or SFTP is not required for automated deployments.
When interactive deployments are required consider using SFTP instead of FTP. Use of FTP alone is not sufficient to prevent disclosure of sensitive information that may be transferred.; displayName=Web apps disable insecure FTP; moduleName=PSRule.Rules.Azure; name=Azure.AppService.WebSecureFtp; recommendation=Consider disabling insecure FTP and configure SFTP only when required. Also consider using Azure Policy to audit or enforce this configuration.; synopsis=Web apps should disable insecure FTP and configure SFTP when required.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000081</td><td>Azure.AppService.WebSecureFtp</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2022_06; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=In an App Service app, you can configure the Node.js runtime version used to run your application or site code.
Extended support for Node.js 18 LTS will end on April 30, 2025. While apps hosted on App Service will continue to operate, security updates and customer support for Node.js 18 LTS will no longer be provided after this date.
To avoid potential security vulnerabilities and minimize risks for your App Service apps, it is recommended to upgrade your apps to Node.js 20 LTS before April 30, 2025.; displayName=Use a supported Node.js runtime version; moduleName=PSRule.Rules.Azure; name=Azure.AppService.NodeJsVersion; recommendation=Consider updating applications to use supported Node.js runtime versions to maintain security and support.; synopsis=Configure applications to use supported Node.js runtime versions.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000428</td><td>Azure.AppService.NodeJsVersion</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2024_06; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service apps must authenticate to Azure resources such as Azure SQL Databases. App Service can use managed identities to authenticate to Azure resource without storing credentials.
Using Azure managed identities have the following benefits:

- You don&#39;t need to store or manage credentials.
Azure automatically generates tokens and performs rotation.
- You can use managed identities to authenticate to any Azure service that supports Azure AD authentication.
- Managed identities can be used without any additional cost.; displayName=App Service apps uses a managed identity; moduleName=PSRule.Rules.Azure; name=Azure.AppService.ManagedIdentity; recommendation=Consider configuring a managed identity for each App Service app. Also consider using managed identities to authenticate to related Azure services.; synopsis=Configure managed identities to access Azure resources.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000082</td><td>Azure.AppService.ManagedIdentity</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_12; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service apps use Application Request Routing (ARR) by default. ARR uses a cookie to route subsequent client requests back to the same instance when an app is scaled to two or more instances. This benefits stateful applications, which may hold session information in instance memory.
For stateless applications, disabling ARR allows Azure App Service more evenly distribute load.; displayName=Disable Application Request Routing; moduleName=PSRule.Rules.Azure; name=Azure.AppService.ARRAffinity; recommendation=Azure App Service sites make use of Application Request Routing (ARR) by default. Consider disabling ARR affinity for stateless applications.; synopsis=Disable client affinity for stateless services.}</td><td>Error</td><td>Fail</td><td>Processed</td><td>AZR-000083</td><td>Azure.AppService.ARRAffinity</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Performance Efficiency}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
<tr><td></td><td>@{resourceGroupName=; resourceId=/subscriptions/ffffffff-ffff-ffff-ffff-ffffffffffff/resourceGroups/ps-rule-test-rg/providers/Microsoft.Web/sites/6950582743e8b; subscriptionId=}</td><td>@{annotations=; description=Azure App Service apps are configured by default to accept encrypted and unencrypted connections. HTTP connections can be automatically redirected to use HTTPS when the HTTPS Only setting is enabled.
Unencrypted communication to App Service apps could allow disclosure of information to an untrusted party.; displayName=App Service allows unencrypted traffic; moduleName=PSRule.Rules.Azure; name=Azure.AppService.UseHTTPS; recommendation=When access using unencrypted HTTP connection is not required consider enabling HTTPS Only. Also consider using Azure Policy to audit or enforce this configuration.; synopsis=Unencrypted communication could allow disclosure of information to an untrusted party.}</td><td>Error</td><td>Pass</td><td>Processed</td><td>AZR-000084</td><td>Azure.AppService.UseHTTPS</td><td>79f7417fbdf7382fea9ec77f5baa0adec505c06f</td><td>System.Object[]</td><td>@{release=GA; ruleSet=2020_06; azure.WAF/pillar=Security}</td><td>6950582743e8b</td><td>Microsoft.Web/sites</td><td>0</td></tr>
</table>
</body></html>
